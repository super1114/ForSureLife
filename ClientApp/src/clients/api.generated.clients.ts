/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.5.0 (NJsonSchema v10.3.7.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export interface IApplicationClient {
    /**
     * Get Application
     */
    get(): Promise<ApplicationDto>;
    /**
     * Create Application
     */
    create(applicationDto: ApplicationDto): Promise<ApplicationDto>;
    /**
     * Update Application
     */
    update(applicationDto: ApplicationDto): Promise<ApplicationDto>;
    /**
     * Delete Application
     */
    delete(applicationId: string): Promise<void>;
    /**
     * Get Application
     */
    getResume(email: string | null, phone: string | null, applicationId: string): Promise<ApplicationDto>;
    /**
     * Get Application
     */
    resumeActivity(email: string | null, phone: string | null): Promise<string>;
    /**
     * Get Application
     */
    resumeActivityChallenge(email: string | null, phone: string | null, challengeCode: string | null): Promise<ApplicationDto>;
    /**
     * Get Application Info
     */
    getApplicationInfo(applicationInfoId: string): Promise<ApplicationInfoDto>;
    /**
     * Create Application Info
     */
    createApplicationInfo(applicationInfoDto: ApplicationInfoDto): Promise<string>;
    /**
     * Update Application Info
     */
    updateApplicationInfo(applicationInfoDto: ApplicationInfoDto): Promise<void>;
    /**
     * Delete Application Info
     */
    deleteApplicationInfo(applicationInfoId: string): Promise<void>;
    /**
     * Get Application Info
     */
    getSeparateOwnerInfo(applicationInfoId: string): Promise<SeparatePolicyOwner>;
    /**
     * Create Separate Owner Info
     */
    createSeparateOwnerInfo(applicationInfoId: string, separatePolicyOwner: SeparatePolicyOwner): Promise<string>;
    /**
     * Update Separate Owner Info
     */
    updateSeparateOwnerInfo(applicationInfoId: string, separatePolicyOwner: SeparatePolicyOwner): Promise<void>;
    /**
     * Delete Separate Owner Info
     */
    deleteSeparateOwnerInfo(applicationInfoId: string): Promise<void>;
}

export class ApplicationClient implements IApplicationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get Application
     */
    get(): Promise<ApplicationDto> {
        let url_ = this.baseUrl + "/api/Application";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ApplicationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ApplicationDto>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationDto>(<any>null);
    }

    /**
     * Create Application
     */
    create(applicationDto: ApplicationDto): Promise<ApplicationDto> {
        let url_ = this.baseUrl + "/api/Application";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(applicationDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<ApplicationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ApplicationDto>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationDto>(<any>null);
    }

    /**
     * Update Application
     */
    update(applicationDto: ApplicationDto): Promise<ApplicationDto> {
        let url_ = this.baseUrl + "/api/Application";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(applicationDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<ApplicationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ApplicationDto>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationDto>(<any>null);
    }

    /**
     * Delete Application
     */
    delete(applicationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Application?";
        if (applicationId === undefined || applicationId === null)
            throw new Error("The parameter 'applicationId' must be defined and cannot be null.");
        else
            url_ += "applicationId=" + encodeURIComponent("" + applicationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get Application
     */
    getResume(email: string | null, phone: string | null, applicationId: string): Promise<ApplicationDto> {
        let url_ = this.baseUrl + "/api/Application/Resume?";
        if (email === undefined)
            throw new Error("The parameter 'email' must be defined.");
        else if(email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (phone === undefined)
            throw new Error("The parameter 'phone' must be defined.");
        else if(phone !== null)
            url_ += "phone=" + encodeURIComponent("" + phone) + "&";
        if (applicationId === undefined || applicationId === null)
            throw new Error("The parameter 'applicationId' must be defined and cannot be null.");
        else
            url_ += "applicationId=" + encodeURIComponent("" + applicationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetResume(_response);
        });
    }

    protected processGetResume(response: Response): Promise<ApplicationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ApplicationDto>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationDto>(<any>null);
    }

    /**
     * Get Application
     */
    resumeActivity(email: string | null, phone: string | null): Promise<string> {
        let url_ = this.baseUrl + "/api/Application/Resume/Send?";
        if (email === undefined)
            throw new Error("The parameter 'email' must be defined.");
        else if(email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (phone === undefined)
            throw new Error("The parameter 'phone' must be defined.");
        else if(phone !== null)
            url_ += "phone=" + encodeURIComponent("" + phone) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResumeActivity(_response);
        });
    }

    protected processResumeActivity(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Get Application
     */
    resumeActivityChallenge(email: string | null, phone: string | null, challengeCode: string | null): Promise<ApplicationDto> {
        let url_ = this.baseUrl + "/api/Application/Resume/ChallengeCode?";
        if (email === undefined)
            throw new Error("The parameter 'email' must be defined.");
        else if(email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (phone === undefined)
            throw new Error("The parameter 'phone' must be defined.");
        else if(phone !== null)
            url_ += "phone=" + encodeURIComponent("" + phone) + "&";
        if (challengeCode === undefined)
            throw new Error("The parameter 'challengeCode' must be defined.");
        else if(challengeCode !== null)
            url_ += "challengeCode=" + encodeURIComponent("" + challengeCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResumeActivityChallenge(_response);
        });
    }

    protected processResumeActivityChallenge(response: Response): Promise<ApplicationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ApplicationDto>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationDto>(<any>null);
    }

    /**
     * Get Application Info
     */
    getApplicationInfo(applicationInfoId: string): Promise<ApplicationInfoDto> {
        let url_ = this.baseUrl + "/api/Application/ApplicationInfo/{applicationInfoId}";
        if (applicationInfoId === undefined || applicationInfoId === null)
            throw new Error("The parameter 'applicationInfoId' must be defined.");
        url_ = url_.replace("{applicationInfoId}", encodeURIComponent("" + applicationInfoId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApplicationInfo(_response);
        });
    }

    protected processGetApplicationInfo(response: Response): Promise<ApplicationInfoDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ApplicationInfoDto>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationInfoDto>(<any>null);
    }

    /**
     * Create Application Info
     */
    createApplicationInfo(applicationInfoDto: ApplicationInfoDto): Promise<string> {
        let url_ = this.baseUrl + "/api/Application/ApplicationInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(applicationInfoDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateApplicationInfo(_response);
        });
    }

    protected processCreateApplicationInfo(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Update Application Info
     */
    updateApplicationInfo(applicationInfoDto: ApplicationInfoDto): Promise<void> {
        let url_ = this.baseUrl + "/api/Application/ApplicationInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(applicationInfoDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateApplicationInfo(_response);
        });
    }

    protected processUpdateApplicationInfo(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete Application Info
     */
    deleteApplicationInfo(applicationInfoId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Application/ApplicationInfo?";
        if (applicationInfoId === undefined || applicationInfoId === null)
            throw new Error("The parameter 'applicationInfoId' must be defined and cannot be null.");
        else
            url_ += "applicationInfoId=" + encodeURIComponent("" + applicationInfoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteApplicationInfo(_response);
        });
    }

    protected processDeleteApplicationInfo(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get Application Info
     */
    getSeparateOwnerInfo(applicationInfoId: string): Promise<SeparatePolicyOwner> {
        let url_ = this.baseUrl + "/api/Application/ApplicationInfo/{applicationInfoId}/SeparateOwner";
        if (applicationInfoId === undefined || applicationInfoId === null)
            throw new Error("The parameter 'applicationInfoId' must be defined.");
        url_ = url_.replace("{applicationInfoId}", encodeURIComponent("" + applicationInfoId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSeparateOwnerInfo(_response);
        });
    }

    protected processGetSeparateOwnerInfo(response: Response): Promise<SeparatePolicyOwner> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SeparatePolicyOwner>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SeparatePolicyOwner>(<any>null);
    }

    /**
     * Create Separate Owner Info
     */
    createSeparateOwnerInfo(applicationInfoId: string, separatePolicyOwner: SeparatePolicyOwner): Promise<string> {
        let url_ = this.baseUrl + "/api/Application/ApplicationInfo/{applicationInfoId}/SeparateOwner";
        if (applicationInfoId === undefined || applicationInfoId === null)
            throw new Error("The parameter 'applicationInfoId' must be defined.");
        url_ = url_.replace("{applicationInfoId}", encodeURIComponent("" + applicationInfoId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(separatePolicyOwner);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSeparateOwnerInfo(_response);
        });
    }

    protected processCreateSeparateOwnerInfo(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Update Separate Owner Info
     */
    updateSeparateOwnerInfo(applicationInfoId: string, separatePolicyOwner: SeparatePolicyOwner): Promise<void> {
        let url_ = this.baseUrl + "/api/Application/ApplicationInfo/{applicationInfoId}/SeparateOwner";
        if (applicationInfoId === undefined || applicationInfoId === null)
            throw new Error("The parameter 'applicationInfoId' must be defined.");
        url_ = url_.replace("{applicationInfoId}", encodeURIComponent("" + applicationInfoId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(separatePolicyOwner);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSeparateOwnerInfo(_response);
        });
    }

    protected processUpdateSeparateOwnerInfo(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete Separate Owner Info
     */
    deleteSeparateOwnerInfo(applicationInfoId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Application/ApplicationInfo/{applicationInfoId}/SeparateOwner";
        if (applicationInfoId === undefined || applicationInfoId === null)
            throw new Error("The parameter 'applicationInfoId' must be defined.");
        url_ = url_.replace("{applicationInfoId}", encodeURIComponent("" + applicationInfoId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSeparateOwnerInfo(_response);
        });
    }

    protected processDeleteSeparateOwnerInfo(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export interface IApplicationHealthQuestionsClient {
    /**
     * Get Application Health Question
     */
    get(): Promise<ApplicationHealthQuestionsDto>;
    /**
     * Create Initial Application Health Questions, Must call before Updating individual Questions
     */
    create(healthQuestionsDto: ApplicationHealthQuestionsDto): Promise<string>;
    /**
     * Update Application Health Questions
     */
    update(healthQuestion: ApplicationHealthQuestionsDto): Promise<void>;
    /**
     * Delete Application Health Questions, Testing Only
     */
    delete(healthQuestionId: string): Promise<void>;
    /**
     * Get Application Health Questions
     */
    getApplicationHealthQuestion(applicationHealthQuestionId: number): Promise<ApplicationHealthQuestionsDto>;
    /**
     * Create Individual Question
     */
    createApplicationHealthQuestion(healthQuestion: ApplicationHealthQuestionDto): Promise<void>;
    /**
     * Update Individual Question
     */
    updateApplicationHealthQuestion(healthQuestion: ApplicationHealthQuestionDto): Promise<void>;
    /**
     * Delete Individual Question, For Testing Only
     */
    deleteApplicationHealthQuestion(healthQuestionId: ApplicationHealthQuestionDto): Promise<void>;
}

export class ApplicationHealthQuestionsClient implements IApplicationHealthQuestionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get Application Health Question
     */
    get(): Promise<ApplicationHealthQuestionsDto> {
        let url_ = this.baseUrl + "/api/Application/HealthQuestions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ApplicationHealthQuestionsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ApplicationHealthQuestionsDto>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationHealthQuestionsDto>(<any>null);
    }

    /**
     * Create Initial Application Health Questions, Must call before Updating individual Questions
     */
    create(healthQuestionsDto: ApplicationHealthQuestionsDto): Promise<string> {
        let url_ = this.baseUrl + "/api/Application/HealthQuestions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(healthQuestionsDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Update Application Health Questions
     */
    update(healthQuestion: ApplicationHealthQuestionsDto): Promise<void> {
        let url_ = this.baseUrl + "/api/Application/HealthQuestions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(healthQuestion);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete Application Health Questions, Testing Only
     */
    delete(healthQuestionId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Application/HealthQuestions/Question/{healthQuestionId}";
        if (healthQuestionId === undefined || healthQuestionId === null)
            throw new Error("The parameter 'healthQuestionId' must be defined.");
        url_ = url_.replace("{healthQuestionId}", encodeURIComponent("" + healthQuestionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get Application Health Questions
     */
    getApplicationHealthQuestion(applicationHealthQuestionId: number): Promise<ApplicationHealthQuestionsDto> {
        let url_ = this.baseUrl + "/api/Application/HealthQuestions/Question/{ApplicationHealthQuestionId}";
        if (applicationHealthQuestionId === undefined || applicationHealthQuestionId === null)
            throw new Error("The parameter 'applicationHealthQuestionId' must be defined.");
        url_ = url_.replace("{ApplicationHealthQuestionId}", encodeURIComponent("" + applicationHealthQuestionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApplicationHealthQuestion(_response);
        });
    }

    protected processGetApplicationHealthQuestion(response: Response): Promise<ApplicationHealthQuestionsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ApplicationHealthQuestionsDto>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationHealthQuestionsDto>(<any>null);
    }

    /**
     * Create Individual Question
     */
    createApplicationHealthQuestion(healthQuestion: ApplicationHealthQuestionDto): Promise<void> {
        let url_ = this.baseUrl + "/api/Application/HealthQuestions/Question";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(healthQuestion);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateApplicationHealthQuestion(_response);
        });
    }

    protected processCreateApplicationHealthQuestion(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Update Individual Question
     */
    updateApplicationHealthQuestion(healthQuestion: ApplicationHealthQuestionDto): Promise<void> {
        let url_ = this.baseUrl + "/api/Application/HealthQuestions/Question";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(healthQuestion);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateApplicationHealthQuestion(_response);
        });
    }

    protected processUpdateApplicationHealthQuestion(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete Individual Question, For Testing Only
     */
    deleteApplicationHealthQuestion(healthQuestionId: ApplicationHealthQuestionDto): Promise<void> {
        let url_ = this.baseUrl + "/api/Application/HealthQuestions/Question";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(healthQuestionId);

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteApplicationHealthQuestion(_response);
        });
    }

    protected processDeleteApplicationHealthQuestion(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export interface IAuthorizeClient {
    /**
     * Create Token
     */
    createToken(login: LoginModelDto): Promise<FileResponse>;
    /**
     * Test Get
     */
    get(): Promise<FileResponse>;
}

export class AuthorizeClient implements IAuthorizeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Create Token
     */
    createToken(login: LoginModelDto): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/auth";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateToken(_response);
        });
    }

    protected processCreateToken(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Test Get
     */
    get(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/auth";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export interface IBankClient {
    /**
     * Get Application
     */
    getBankName(bankName: string | null): Promise<BankInfo[]>;
    /**
     * Get Application
     */
    getRoutingInfo(routingNumber: string | null): Promise<BankInfo>;
    /**
     * Get Application
     */
    getBirthPlaces(name: string | null): Promise<BirthPlaces>;
    /**
     * Get Application
     */
    getDoctors(name: string | null): Promise<BirthPlaces>;
}

export class BankClient implements IBankClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get Application
     */
    getBankName(bankName: string | null): Promise<BankInfo[]> {
        let url_ = this.baseUrl + "/api/Bank/Name/{bankName}";
        if (bankName === undefined || bankName === null)
            throw new Error("The parameter 'bankName' must be defined.");
        url_ = url_.replace("{bankName}", encodeURIComponent("" + bankName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBankName(_response);
        });
    }

    protected processGetBankName(response: Response): Promise<BankInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BankInfo[]>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BankInfo[]>(<any>null);
    }

    /**
     * Get Application
     */
    getRoutingInfo(routingNumber: string | null): Promise<BankInfo> {
        let url_ = this.baseUrl + "/api/Bank/Routing/{routingNumber}";
        if (routingNumber === undefined || routingNumber === null)
            throw new Error("The parameter 'routingNumber' must be defined.");
        url_ = url_.replace("{routingNumber}", encodeURIComponent("" + routingNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRoutingInfo(_response);
        });
    }

    protected processGetRoutingInfo(response: Response): Promise<BankInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BankInfo>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BankInfo>(<any>null);
    }

    /**
     * Get Application
     */
    getBirthPlaces(name: string | null): Promise<BirthPlaces> {
        let url_ = this.baseUrl + "/api/locations/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBirthPlaces(_response);
        });
    }

    protected processGetBirthPlaces(response: Response): Promise<BirthPlaces> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BirthPlaces>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BirthPlaces>(<any>null);
    }

    /**
     * Get Application
     */
    getDoctors(name: string | null): Promise<BirthPlaces> {
        let url_ = this.baseUrl + "/api/doctors/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDoctors(_response);
        });
    }

    protected processGetDoctors(response: Response): Promise<BirthPlaces> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BirthPlaces>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BirthPlaces>(<any>null);
    }
}

export interface IBeneficiaryClient {
    /**
     * Get All Beneficiaries
     */
    get(): Promise<BeneficiariesDto>;
    /**
     * Create Beneficiaries
     */
    create(beneficiariesDto: BeneficiariesDto[]): Promise<string>;
    /**
     * Update Beneficiaries
     */
    update(beneficiariesDto: BeneficiariesDto[]): Promise<void>;
    /**
     * Get All Beneficiaries
     */
    getSingle(beneficiariesId: string): Promise<BeneficiariesDto>;
    /**
     * Create Beneficiary
     */
    createBeneficiary(beneficiariesDto: BeneficiaryDto): Promise<string>;
    /**
     * Update Beneficiary
     */
    updateBeneficiary(beneficiariesDto: BeneficiaryDto): Promise<void>;
    /**
     * Delete Beneficiary
     */
    deleteBeneficiary(beneficiariesDto: string, beneficiariesId: string): Promise<void>;
}

export class BeneficiaryClient implements IBeneficiaryClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get All Beneficiaries
     */
    get(): Promise<BeneficiariesDto> {
        let url_ = this.baseUrl + "/api/Application/Beneficiaries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<BeneficiariesDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BeneficiariesDto>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BeneficiariesDto>(<any>null);
    }

    /**
     * Create Beneficiaries
     */
    create(beneficiariesDto: BeneficiariesDto[]): Promise<string> {
        let url_ = this.baseUrl + "/pi/Application/Beneficiaries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(beneficiariesDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Update Beneficiaries
     */
    update(beneficiariesDto: BeneficiariesDto[]): Promise<void> {
        let url_ = this.baseUrl + "/pi/Application/Beneficiaries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(beneficiariesDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get All Beneficiaries
     */
    getSingle(beneficiariesId: string): Promise<BeneficiariesDto> {
        let url_ = this.baseUrl + "/api/Application/Beneficiaries/Benficiary/{beneficiariesId}";
        if (beneficiariesId === undefined || beneficiariesId === null)
            throw new Error("The parameter 'beneficiariesId' must be defined.");
        url_ = url_.replace("{beneficiariesId}", encodeURIComponent("" + beneficiariesId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSingle(_response);
        });
    }

    protected processGetSingle(response: Response): Promise<BeneficiariesDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BeneficiariesDto>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BeneficiariesDto>(<any>null);
    }

    /**
     * Create Beneficiary
     */
    createBeneficiary(beneficiariesDto: BeneficiaryDto): Promise<string> {
        let url_ = this.baseUrl + "/pi/Application/Beneficiaries/Beneficiary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(beneficiariesDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateBeneficiary(_response);
        });
    }

    protected processCreateBeneficiary(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Update Beneficiary
     */
    updateBeneficiary(beneficiariesDto: BeneficiaryDto): Promise<void> {
        let url_ = this.baseUrl + "/pi/Application/Beneficiaries/Beneficiary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(beneficiariesDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateBeneficiary(_response);
        });
    }

    protected processUpdateBeneficiary(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete Beneficiary
     */
    deleteBeneficiary(beneficiariesDto: string, beneficiariesId: string): Promise<void> {
        let url_ = this.baseUrl + "/pi/Application/Beneficiaries/Beneficiary/{beneficiariesId}?";
        if (beneficiariesId === undefined || beneficiariesId === null)
            throw new Error("The parameter 'beneficiariesId' must be defined.");
        url_ = url_.replace("{beneficiariesId}", encodeURIComponent("" + beneficiariesId));
        if (beneficiariesDto === undefined || beneficiariesDto === null)
            throw new Error("The parameter 'beneficiariesDto' must be defined and cannot be null.");
        else
            url_ += "beneficiariesDto=" + encodeURIComponent("" + beneficiariesDto) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteBeneficiary(_response);
        });
    }

    protected processDeleteBeneficiary(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export interface ILeadClient {
    /**
     * Create Lead
     */
    post(leadInfo: LeadDTO): Promise<string>;
    /**
     * Update Lead
     */
    patch(leadInfo: LeadDTO): Promise<void>;
    /**
     * Get Lead by Id
     */
    get(leadId: string): Promise<LeadDTO>;
    /**
     * Delete Lead, Testing Only
     */
    delete(leadId: string): Promise<void>;
    /**
     * Submit Sale of Lead
     */
    integrityLeadPost(leads: LeadSaleDto): Promise<string>;
    /**
     * Submit Sale of Lead
     */
    bulkIntegrityLeadPost(leads: BulkLeadSaleDto): Promise<string>;
}

export class LeadClient implements ILeadClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Create Lead
     */
    post(leadInfo: LeadDTO): Promise<string> {
        let url_ = this.baseUrl + "/api/lead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(leadInfo);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <string>jsonParse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Update Lead
     */
    patch(leadInfo: LeadDTO): Promise<void> {
        let url_ = this.baseUrl + "/api/lead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(leadInfo);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPatch(_response);
        });
    }

    protected processPatch(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get Lead by Id
     */
    get(leadId: string): Promise<LeadDTO> {
        let url_ = this.baseUrl + "/api/lead?";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined and cannot be null.");
        else
            url_ += "leadId=" + encodeURIComponent("" + leadId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<LeadDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LeadDTO>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeadDTO>(<any>null);
    }

    /**
     * Delete Lead, Testing Only
     */
    delete(leadId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/lead?";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined and cannot be null.");
        else
            url_ += "leadId=" + encodeURIComponent("" + leadId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Submit Sale of Lead
     */
    integrityLeadPost(leads: LeadSaleDto): Promise<string> {
        let url_ = this.baseUrl + "/api/lead/LeadSale";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(leads);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIntegrityLeadPost(_response);
        });
    }

    protected processIntegrityLeadPost(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <string>jsonParse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Submit Sale of Lead
     */
    bulkIntegrityLeadPost(leads: BulkLeadSaleDto): Promise<string> {
        let url_ = this.baseUrl + "/api/lead/LeadSales";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(leads);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulkIntegrityLeadPost(_response);
        });
    }

    protected processBulkIntegrityLeadPost(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <string>jsonParse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }
}

export interface ILeadHealthQuestionsClient {
    /**
     * Get Health Question
     */
    get(healthQuestionId: string): Promise<LeadHealthQuestionsDto>;
    /**
     * Create Initial HealthQuestions, Must call before Updating individual Questions
     */
    create(healthQuestionsDto: LeadHealthQuestionsDto[]): Promise<string>;
    /**
     * Delete Lead Health Questions, Testing Only
     */
    delete(healthQuestionId: string): Promise<void>;
    /**
     * Get Individual Lead Health Question
     */
    getLeadHealthQuestion(leadHealthQuestionId: number): Promise<LeadHealthQuestionDto>;
    /**
     * Create Individual Question
     */
    createLeadHealthQuestion(healthQuestion: LeadHealthQuestionDto): Promise<void>;
    /**
     * Update Individual Question
     */
    updateLeadHealthQuestion(healthQuestion: LeadHealthQuestionDto): Promise<void>;
    /**
     * Delete Individual Question, For Testing Only
     */
    deleteLeadHealthQuestion(healthQuestionId: LeadHealthQuestions): Promise<void>;
}

export class LeadHealthQuestionsClient implements ILeadHealthQuestionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get Health Question
     */
    get(healthQuestionId: string): Promise<LeadHealthQuestionsDto> {
        let url_ = this.baseUrl + "/api/LeadHealthQuestions?";
        if (healthQuestionId === undefined || healthQuestionId === null)
            throw new Error("The parameter 'healthQuestionId' must be defined and cannot be null.");
        else
            url_ += "healthQuestionId=" + encodeURIComponent("" + healthQuestionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<LeadHealthQuestionsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LeadHealthQuestionsDto>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeadHealthQuestionsDto>(<any>null);
    }

    /**
     * Create Initial HealthQuestions, Must call before Updating individual Questions
     */
    create(healthQuestionsDto: LeadHealthQuestionsDto[]): Promise<string> {
        let url_ = this.baseUrl + "/api/LeadHealthQuestions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(healthQuestionsDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Delete Lead Health Questions, Testing Only
     */
    delete(healthQuestionId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/LeadHealthQuestions/{healthQuestionId}";
        if (healthQuestionId === undefined || healthQuestionId === null)
            throw new Error("The parameter 'healthQuestionId' must be defined.");
        url_ = url_.replace("{healthQuestionId}", encodeURIComponent("" + healthQuestionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get Individual Lead Health Question
     */
    getLeadHealthQuestion(leadHealthQuestionId: number): Promise<LeadHealthQuestionDto> {
        let url_ = this.baseUrl + "/api/LeadHealthQuestions/Question/{leadHealthQuestionId}";
        if (leadHealthQuestionId === undefined || leadHealthQuestionId === null)
            throw new Error("The parameter 'leadHealthQuestionId' must be defined.");
        url_ = url_.replace("{leadHealthQuestionId}", encodeURIComponent("" + leadHealthQuestionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLeadHealthQuestion(_response);
        });
    }

    protected processGetLeadHealthQuestion(response: Response): Promise<LeadHealthQuestionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LeadHealthQuestionDto>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeadHealthQuestionDto>(<any>null);
    }

    /**
     * Create Individual Question
     */
    createLeadHealthQuestion(healthQuestion: LeadHealthQuestionDto): Promise<void> {
        let url_ = this.baseUrl + "/api/LeadHealthQuestions/Question";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(healthQuestion);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateLeadHealthQuestion(_response);
        });
    }

    protected processCreateLeadHealthQuestion(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Update Individual Question
     */
    updateLeadHealthQuestion(healthQuestion: LeadHealthQuestionDto): Promise<void> {
        let url_ = this.baseUrl + "/api/LeadHealthQuestions/Question";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(healthQuestion);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateLeadHealthQuestion(_response);
        });
    }

    protected processUpdateLeadHealthQuestion(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete Individual Question, For Testing Only
     */
    deleteLeadHealthQuestion(healthQuestionId: LeadHealthQuestions): Promise<void> {
        let url_ = this.baseUrl + "/api/LeadHealthQuestions/Question/{healthQuestionId}";
        if (healthQuestionId === undefined || healthQuestionId === null)
            throw new Error("The parameter 'healthQuestionId' must be defined.");
        url_ = url_.replace("{healthQuestionId}", encodeURIComponent("" + healthQuestionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteLeadHealthQuestion(_response);
        });
    }

    protected processDeleteLeadHealthQuestion(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export interface IPaymentClient {
    /**
     * Get Payment
     */
    get(paymentId: string): Promise<PaymentInfoDto>;
    /**
     * Create Payment
     */
    create(paymentInfo: PaymentInfoDto): Promise<string>;
    /**
     * Update Payment
     */
    update(paymentInfo: PaymentInfoDto): Promise<void>;
    /**
     * Delete Payment
     */
    delete(paymentId: string): Promise<void>;
}

export class PaymentClient implements IPaymentClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get Payment
     */
    get(paymentId: string): Promise<PaymentInfoDto> {
        let url_ = this.baseUrl + "/api/Payment?";
        if (paymentId === undefined || paymentId === null)
            throw new Error("The parameter 'paymentId' must be defined and cannot be null.");
        else
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<PaymentInfoDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PaymentInfoDto>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentInfoDto>(<any>null);
    }

    /**
     * Create Payment
     */
    create(paymentInfo: PaymentInfoDto): Promise<string> {
        let url_ = this.baseUrl + "/api/Payment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(paymentInfo);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Update Payment
     */
    update(paymentInfo: PaymentInfoDto): Promise<void> {
        let url_ = this.baseUrl + "/api/Payment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(paymentInfo);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete Payment
     */
    delete(paymentId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Payment?";
        if (paymentId === undefined || paymentId === null)
            throw new Error("The parameter 'paymentId' must be defined and cannot be null.");
        else
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export interface IQuoteClient {
    /**
     * Get Quote by Id
     */
    getQuote(applicationId: string): Promise<QuoteDto>;
    /**
     * Update Application Health Questions
     */
    getAmAmApplication(applicationId: string): Promise<AAFinalExpense>;
    /**
     * Update Application Health Questions
     */
    updateAmAmApplication(application: AAFinalExpense): Promise<AAFinalExpense>;
    /**
     * Update Application Health Questions
     */
    submitAmAmApplication(applicationId: string): Promise<AAFinalExpense>;
    /**
     * Update Application Health Questions
     */
    getAmAmApplicationPDF(): Promise<FileResponse>;
}

export class QuoteClient implements IQuoteClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get Quote by Id
     */
    getQuote(applicationId: string): Promise<QuoteDto> {
        let url_ = this.baseUrl + "/api/quote?";
        if (applicationId === undefined || applicationId === null)
            throw new Error("The parameter 'applicationId' must be defined and cannot be null.");
        else
            url_ += "applicationId=" + encodeURIComponent("" + applicationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetQuote(_response);
        });
    }

    protected processGetQuote(response: Response): Promise<QuoteDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <QuoteDto>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<QuoteDto>(<any>null);
    }

    /**
     * Update Application Health Questions
     */
    getAmAmApplication(applicationId: string): Promise<AAFinalExpense> {
        let url_ = this.baseUrl + "/api/Application/AmAmApplication?";
        if (applicationId === undefined || applicationId === null)
            throw new Error("The parameter 'applicationId' must be defined and cannot be null.");
        else
            url_ += "applicationId=" + encodeURIComponent("" + applicationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAmAmApplication(_response);
        });
    }

    protected processGetAmAmApplication(response: Response): Promise<AAFinalExpense> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AAFinalExpense>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AAFinalExpense>(<any>null);
    }

    /**
     * Update Application Health Questions
     */
    updateAmAmApplication(application: AAFinalExpense): Promise<AAFinalExpense> {
        let url_ = this.baseUrl + "/api/Application/AmAmApplication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(application);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAmAmApplication(_response);
        });
    }

    protected processUpdateAmAmApplication(response: Response): Promise<AAFinalExpense> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AAFinalExpense>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AAFinalExpense>(<any>null);
    }

    /**
     * Update Application Health Questions
     */
    submitAmAmApplication(applicationId: string): Promise<AAFinalExpense> {
        let url_ = this.baseUrl + "/api/Application/AmAmApplication?";
        if (applicationId === undefined || applicationId === null)
            throw new Error("The parameter 'applicationId' must be defined and cannot be null.");
        else
            url_ += "applicationId=" + encodeURIComponent("" + applicationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubmitAmAmApplication(_response);
        });
    }

    protected processSubmitAmAmApplication(response: Response): Promise<AAFinalExpense> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AAFinalExpense>jsonParse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AAFinalExpense>(<any>null);
    }

    /**
     * Update Application Health Questions
     */
    getAmAmApplicationPDF(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Application/AmAmApplication/pdf";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAmAmApplicationPDF(_response);
        });
    }

    protected processGetAmAmApplicationPDF(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export interface ApplicationDto {
    applicationId: string | undefined;
    leadInfo: LeadDTO | undefined;
    healthQuestions: ApplicationHealthQuestionDto[] | undefined;
    applicationInfo: ApplicationInfoDto | undefined;
    beneficiaries: BeneficiaryDto[] | undefined;
    contingentBeneficiaries: BeneficiaryDto[] | undefined;
    designee: DesigneeDto | undefined;
    paymentInfo: PaymentInfoDto | undefined;
    signed: boolean | undefined;
    signedDate: string | undefined;
    omniSendContactId: string | undefined;
}

export interface LeadDTO {
    leadId: string;
    leadSource: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    state: string | undefined;
    zipCode: string | undefined;
    city: string | undefined;
    county: string | undefined;
    desiredBeneficiary: Relationship;
    dob: string;
    currentCoverage: boolean;
    desiredCoverageAmount: number;
    originalDesiredCoverageAmount: number;
    hobby: string | undefined;
    gender: Gender;
    externalLeadId: string | undefined;
    isEligible: boolean;
    healthQuestionsAnswered: boolean;
    clickedApplied: boolean;
    clickedEnrolled: boolean;
    contactAgent: boolean;
    knockedOut: boolean;
    beneficiarySet: boolean;
    leadCompleted: boolean;
    quoteReceived: boolean;
    paymentDateSet: boolean;
    paymentAccountSet: boolean;
    socialSet: boolean;
    reviewPageSeen: boolean;
    reviewPageSubmit: boolean;
    secondQuoteReceived: boolean;
    selectedBenefitAmount: number;
    selectedMonthlyRate: number;
    premiumType: SeniorChoicePremiumType;
    healthQuestions: LeadHealthQuestionDto[] | undefined;
}

export enum Relationship {
    NoRelationship = 0,
    Primary = 1,
    Spouse = 2,
    ChildDaughter = 3,
    ChildSon = 4,
    Mother = 5,
    Father = 6,
    Brother = 7,
    Sister = 8,
    Cousin = 9,
    Aunt = 10,
    Uncle = 11,
    GrandFather = 12,
    GrandMother = 13,
    GrandParent = 14,
    GrandChild = 15,
    Niece = 16,
    Nephew = 17,
    Child = 18,
    Relative = 19,
    Other = 20,
    SeparatePolicyOwnerSpouse = 21,
    SeparatePolicyOwnerLifePartner = 22,
    SeparatePolicyOwnerFiance = 23,
    SeparatePolicyOwnerChild = 24,
    SeparatePolicyOwnerOther = 25,
    Fiance = 26,
    Estate = 27,
    Trust = 28,
    LifePartner = 29,
}

export enum Gender {
    Male = 0,
    Female = 1,
}

export enum SeniorChoicePremiumType {
    Immediate = 0,
    Graded = 1,
    Premium = 2,
    NotEligible = 3,
}

export interface LeadHealthQuestionDto {
    healthQuestionId: string;
    leadHealthQuestion: LeadHealthQuestions;
    healthQuestionName: string | undefined;
    healthAnswer: boolean;
    occurence: Occurence;
}

export enum LeadHealthQuestions {
    NotAvailable = 0,
    TobaccoUse = 1,
    ChronicIllness = 2,
    HospiceCare = 3,
    SelfReliant = 4,
    OtherDisease = 5,
    Cancer = 6,
    MultipleCancer = 7,
    Oxygen = 8,
    OrganDialysisDisease = 9,
    LivePast12Months = 10,
    Hospitilized = 11,
}

export enum Occurence {
    NullValue = 0,
    Current = 1,
    TwoYears = 2,
    TwoToThreeYears = 3,
    MoreThanThreeYears = 4,
    Multiple = 5,
}

export interface ApplicationHealthQuestionDto {
    healthQuestionId: string;
    applicationQuestion: ApplicationHealthQuestions;
    healthQuestionName: string | undefined;
    healthAnswer: boolean;
    occurence: Occurence;
}

export enum ApplicationHealthQuestions {
    NullValue = 0,
    HeartAttack = 1,
    HepatitisC = 2,
    RenalInsufficiencey = 3,
    COPD = 4,
    Circulation = 5,
    OutstandingResults = 6,
    DiabetesComplications = 7,
    AbusedSubstances = 8,
    Cardiomyopathy = 9,
    LiverDisease = 10,
    Parkinsons = 11,
    Paralysis = 12,
    CovidQuestionMain = 13,
    Covid2 = 14,
    CovidQuestionThree = 15,
    CovidEffectsMain = 16,
    CovidWithin90DaysMain = 17,
    Covid2Effects = 18,
    Covid290Days = 19,
}

export interface ApplicationInfoDto {
    applicationInfoId: string;
    dob: string;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    ssn: string | undefined;
    separateOwner: boolean;
    lifePolicy: boolean;
    lifePolicyInsuranceCompany: string | undefined;
    lifePolicyNumber: string | undefined;
    lifeCoverageAmount: number;
    heightFt: number | undefined;
    heightIn: number | undefined;
    weight: number;
    stateOfBirth: string | undefined;
    validApplyStates: string[] | undefined;
    doctorName: string | undefined;
    doctorState: States;
    doctorCity: string | undefined;
    doctorPhone: string | undefined;
    separatePolicyOwner: SeparatePolicyOwner | undefined;
    acceptAnyPlan: boolean;
}

export enum States {
    AL = 0,
    AK = 1,
    AR = 2,
    AZ = 3,
    CA = 4,
    CO = 5,
    CT = 6,
    DC = 7,
    DE = 8,
    FL = 9,
    GA = 10,
    HI = 11,
    IA = 12,
    ID = 13,
    IL = 14,
    IN = 15,
    KS = 16,
    KY = 17,
    LA = 18,
    MA = 19,
    MD = 20,
    ME = 21,
    MI = 22,
    MN = 23,
    MO = 24,
    MS = 25,
    MT = 26,
    NC = 27,
    ND = 28,
    NE = 29,
    NH = 30,
    NJ = 31,
    NM = 32,
    NV = 33,
    NY = 34,
    OK = 35,
    OH = 36,
    OR = 37,
    PA = 38,
    RI = 39,
    SC = 40,
    SD = 41,
    TN = 42,
    TX = 43,
    UT = 44,
    VA = 45,
    VT = 46,
    WA = 47,
    WI = 48,
    WV = 49,
    WY = 50,
}

export interface SeparatePolicyOwner {
    separatePolicyOwnerId: string;
    beneficiaryId: string;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    relationship: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    city: string | undefined;
    state: string | undefined;
    ssn: string | undefined;
    policyOwnerRelationship: Relationship;
}

export interface BeneficiaryDto {
    beneficiaryId: string;
    primaryRelationship: Relationship;
    personalInfo: FamilyMemberDto | undefined;
    relationship: string | undefined;
    percentage: number;
}

export interface FamilyMemberDto {
    familyMemberId: string;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    city: string | undefined;
    dateOfBirth: string;
    state: string | undefined;
    stateOfBirth: string | undefined;
    ssn: string | undefined;
    heightFt: number;
    heightIn: number;
    weight: number;
}

export interface DesigneeDto {
    designeeId: string;
    firstName: string | undefined;
    lastName: string | undefined;
    address1: string | undefined;
    city: string | undefined;
    state: string | undefined;
    zipCode: string | undefined;
    emailAddress: string | undefined;
    telephone: string | undefined;
    signed: boolean;
}

export interface PaymentInfoDto {
    paymentId: string;
    bankingInsitution: string | undefined;
    paymentType: PaymentType;
    creditCardRef: string | undefined;
    bankAddress: string | undefined;
    accountNumber: string | undefined;
    routingNumber: string | undefined;
    bankType: AccountType;
    paymentWithdrawlDate: number;
    socialSecurityWithdrawDate: SSDDate;
}

export enum PaymentType {
    BankDraft = 0,
    Debit = 1,
    Credit = 2,
}

export enum AccountType {
    Checking = 0,
    Savings = 1,
}

export enum SSDDate {
    FirststDOM = 0,
    ThirdDOM = 1,
    SecondW = 2,
    ThirdW = 3,
    ForthW = 4,
}

export interface ApplicationHealthQuestionsDto {
    applicationHealthQuestionId: string;
}

export interface LoginModelDto {
    username: string | undefined;
    password: string | undefined;
    applicationId: string;
}

export interface BankInfo {
    bankInfoId: string;
    routingNumber: string | undefined;
    bankName: string | undefined;
    address1: string | undefined;
    state: string | undefined;
    city: string | undefined;
}

export interface BirthPlaces {
    birthPlacesId: string;
    name: string | undefined;
    abbreviation: string | undefined;
}

export interface BeneficiariesDto {
    beneficiariesId: string;
    beneficiaries: BeneficiaryDto[] | undefined;
}

export interface LeadSaleDto {
    leadId: string;
    apiKey: string | undefined;
}

export interface BulkLeadSaleDto {
    leadId: string[] | undefined;
    apiKey: string | undefined;
}

export interface LeadHealthQuestionsDto {
    leadHealthQuestionID: string;
    healthQuestions: LeadHealthQuestionDto[] | undefined;
}

export interface QuoteDto {
    selectedBenefitAmount: number;
    selectedMonthlyRate: number;
    premiumType: SeniorChoicePremiumType;
    planInfo: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    state: string | undefined;
    zipCode: string | undefined;
    city: string | undefined;
    age: number;
    rates: RateDto[] | undefined;
    susaRates: RateDto[] | undefined;
    foresterRates: RateDto[] | undefined;
    eagleRates: RateDto[] | undefined;
}

export interface RateDto {
    selectedCoverage: boolean;
    benefitCoverage: number;
    monthlyRate: number;
    annualRate: number;
}

export interface AAFinalExpense {
    aaFinalExpenseId: string;
    applicationState: States;
    selectedBenefitAmount: number;
    selectedMonthlyRate: number;
    premiumType: SeniorChoicePremiumType;
    mailPolicyTo: MailPolicy;
    effectiveDate: string;
    insuranceCompanyName: InsuranceCompany;
    licenseNumber: string | undefined;
    signed: boolean;
    signedDate: string;
    signatureLocationCity: string | undefined;
    signatureLocationState: string | undefined;
    clientIPAddress: string | undefined;
    fileNumber: number;
    testChange: number;
    submitted: boolean;
    applicationAnswers: AmAmApplicationAnswers[] | undefined;
    application: Application | undefined;
}

export enum MailPolicy {
    Agent = 0,
    Insured = 1,
    Owner = 2,
}

export enum InsuranceCompany {
    AmericanAmicable = 0,
    Occidental = 1,
}

export interface AmAmApplicationAnswers {
    amAmApplicationAnswersId: string;
    question: AmAmApplicationQuestions | undefined;
    answer: boolean;
}

export interface AmAmApplicationQuestions {
    amAmApplicationQuestionsId: string;
    questionName: AmAmApplicationQuestion;
    applicationSection: ApplicationSection;
    states: AmStateLookup[] | undefined;
}

export enum AmAmApplicationQuestion {
    Question1 = 0,
    Question2 = 1,
    Question3 = 2,
    Question4 = 3,
    Question5 = 4,
    Question6 = 5,
    Question7a = 6,
    Question7b = 7,
    Question7c = 8,
    Question7d = 9,
    Question8a = 10,
    Question8b = 11,
    Question8c = 12,
}

export enum ApplicationSection {
    KnockOut = 0,
    Graded = 1,
    Modified = 2,
}

export interface AmStateLookup {
    amStateLookupId: string;
    amState: AmState | undefined;
}

export interface AmState {
    amStateId: string;
    stateIdEnum: States;
    insuranceCompany: InsuranceCompany;
    licenseNumber: string | undefined;
}

export interface Application {
    applicationId: string;
    leadInfo: Lead | undefined;
    healthQuestions: HealthQuestion[] | undefined;
    selectedQuotes: Quote[] | undefined;
    beneficiaries: FamilyOrBeneficiary[] | undefined;
    contingentBeneficiaries: FamilyOrBeneficiary[] | undefined;
    designee: Designee | undefined;
    applicationInfo: ApplicationInfo | undefined;
    paymentInfo: PaymentInfo | undefined;
    language: string | undefined;
    signed: boolean;
    signedDate: string;
    createdDate: string;
    updateDate: string;
    leadCaputred: boolean;
    immediateLeadCaptured: boolean;
    sentToIntegrity: boolean;
    immediateLeadEmailed: boolean;
    quoteLeadEmailed: boolean;
    omniSendContactId: string | undefined;
    saleCaputured: boolean;
    immediateLeadSendToIntegrity: boolean;
    challengeCode: string | undefined;
    expirationDate: string;
}

export interface Lead {
    leadId: string;
    leadSource: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    state: string | undefined;
    zipCode: string | undefined;
    city: string | undefined;
    county: string | undefined;
    desiredBeneficiary: Relationship;
    dob: string;
    currentCoverage: boolean;
    desiredCoverageAmount: number;
    originalDesiredCoverageAmount: number;
    hobby: string | undefined;
    gender: Gender;
    externalLeadId: string | undefined;
    isEligible: boolean;
    healthQuestionsAnswered: boolean;
    clickedApplied: boolean;
    clickedEnrolled: boolean;
    contactAgent: boolean;
    knockedOut: boolean;
    beneficiarySet: boolean;
    leadCompleted: boolean;
    quoteReceived: boolean;
    paymentDateSet: boolean;
    paymentAccountSet: boolean;
    socialSet: boolean;
    reviewPageSeen: boolean;
    reviewPageSubmit: boolean;
    secondQuoteReceived: boolean;
    selectedBenefitAmount: number;
    selectedMonthlyRate: number;
    premiumType: SeniorChoicePremiumType;
}

export interface HealthQuestion {
    healthQuestionId: string;
    leadHealthQuestion: LeadHealthQuestions;
    applicationQuestion: ApplicationHealthQuestions;
    healthQuestionName: string | undefined;
    healthAnswer: boolean;
    occurence: Occurence;
}

export interface Quote {
    id: string;
    zipCode: string | undefined;
    plans: PlanQuote[] | undefined;
}

export interface PlanQuote {
    planQuoteId: string;
    planId: string | undefined;
    planName: string | undefined;
    carrier: string | undefined;
    benefitLevel: PlanBenefit | undefined;
    effectiveDate: string;
}

export interface PlanBenefit {
    planBenefitId: string;
    benefitName: string | undefined;
    benefitAmount: string | undefined;
}

export interface FamilyOrBeneficiary {
    familyOrBeneficiaryId: string;
    personalInfo: FamilyMember | undefined;
    primaryRelationship: Relationship;
    relationships: string | undefined;
    percentage: number;
}

export interface FamilyMember {
    familyMemberId: string;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    city: string | undefined;
    dateOfBirth: string;
    state: string | undefined;
    stateOfBirth: string | undefined;
    ssn: string | undefined;
    heightFt: number;
    heightIn: number;
    weight: number;
    gender: Gender;
}

export interface Designee {
    designeeId: string;
    firstName: string | undefined;
    lastName: string | undefined;
    address1: string | undefined;
    city: string | undefined;
    state: string | undefined;
    zipCode: string | undefined;
    emailAddress: string | undefined;
    telephone: string | undefined;
    signed: boolean;
}

export interface ApplicationInfo {
    applicationInfoId: string;
    dob: string;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    ssn: string | undefined;
    separateOwner: boolean;
    lifePolicy: boolean;
    lifePolicyInsuranceCompany: string | undefined;
    lifePolicyNumber: string | undefined;
    lifeCoverageAmount: number;
    heightFt: number | undefined;
    heightIn: number | undefined;
    weight: number;
    birthState: string | undefined;
    stateOfBirth: string | undefined;
    doctorName: string | undefined;
    doctorState: States;
    doctorCity: string | undefined;
    doctorPhone: string | undefined;
    acceptAnyPlan: boolean;
}

export interface PaymentInfo {
    paymentId: string;
    paymentType: PaymentType;
    creditCardRef: string | undefined;
    bankingInsitution: string | undefined;
    bankAddress: string | undefined;
    accountNumber: string | undefined;
    routingNumber: string | undefined;
    bankType: AccountType;
    paymentWithdrawlDate: number;
    socialSecurityWithdrawDate: SSDDate;
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T | null {
  if (!mappings)
    mappings = [];
  if (!data)
    return null;

  const mappingIndexName = "__mappingIndex";
  if (data[mappingIndexName])
    return <T>mappings[data[mappingIndexName]].target;

  data[mappingIndexName] = mappings.length;

  let result: any = new type();
  mappings.push({ source: data, target: result });
  result.init(data, mappings);
  return result;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}